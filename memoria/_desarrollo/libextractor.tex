De las distintas alternativas posibles para la extracción de metadatos se decidió usar libextractor por multiples razones:

\begin{itemize}
  \item Lenguaje: Al ser una librería escrita en C, estamos seguros de que la máquina virtual de Erlang va a ser compatible. También es tranquilizador saber que si fuera necesario, puedo modificar el código fuente de forma relativamente fácil y rápida.
  \item Plugins: Libextractor está pensado para ser expandido con nuevos formatos. Cada formato que puede leer esta aislado en un plugin externo que se encarga de parsear el archivo y devolver los metadatos encontrados. Esto nos permite expandir las capacidades de Krptkn o quitar plugins que no sean necesarios o estén anticuados.
  \item Procesos aislados: Una característica importante del funcionamiento de libextractor es que las llamadas a los plugins externos son usando $fork$. Esto nos asegura que lo peor que puede ocurrir cuando intentamos extraer metadatos de un archivo corrupto o maligno es que el proceso del plugin muera y no nos devuelva metadatos. 
\end{itemize}

A pesar de que estas características son muy importantes, libextractor también tiene multiples inconvenientes:
\begin{itemize}
  \item Lentitud: A pesar de estar escrito en C, el cargar los plugins, crear un fork y copiar los datos del archivo a analizar puede ser demasiado lento en comparación con el spider de Krptkn. Debido a esto, la velocidad de exploración de Krptkn se ve limitada.
  \item Paralelismo: Una de las principales ventajas de el uso de Erlang/Elixir y OTP es su capacidad para paralelizar el código de forma muy simple. El estar usando una librería nativa que hace uso de forks y lee librerías compartidas (.so, .a, .o) hace imposible aprovechar el paralelismo que se usa en el resto de módulos de Krptkn..
\end{itemize}

Estos problemas se podrían eliminar a la vez que mantenemos las ventajas haciendo uso de una librería de extracción de metadatos escrita en Elixir. Esto nos permitiría hacer uso de tantos procesos paralelos como fuera necesario y acelerando mucho la ejecución. En las fases iniciales de desarrollo se intentó crear un módulo para leer los metadatos de archivos PNG y se concluyó que aunque la creación del parser había sido bastante rápida (entre dos y tres horas), desarrollar los módulos necesarios para igualar a libextractor (pdf, word, mp3, ogg, avi, deb, etc.) iba a ser imposible sin un equipo y más tiempo.

En conclusión, lo más adecuado ahora mismo es usar libextractor y si fuera posible, ir desarrollando parsers en Elixir para acelerar la fase de extracción. Ambos pueden ser usados a la vez gracias a la arquitectura de Krptkn por lo que el desarrollo de un parser para archivos que sabemos que son muy comunes (pdf o word) podría acelerar mucho el sistema sin emplear demasiado tiempo.
