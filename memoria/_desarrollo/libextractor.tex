De las distintas alternativas posibles para la extracción de metadatos se decidió usar libextractor por multiples razones:

\begin{itemize}
  \item Lenguaje: Al ser una librería escrita en C, estamos seguros de que la máquina virtual de Erlang va a ser compatible. También es tranquilizador saber que si fuera necesario, es posible modificar el código fuente de forma relativamente fácil y rápida.
  \item Plugins: Libextractor está pensado para ser expandido con nuevos formatos. Cada formato que puede leer esta aislado en un plugin externo que se encarga de parsear el archivo y devolver los metadatos encontrados. Esto nos permite expandir las capacidades de Krptkn o quitar plugins que no sean necesarios o estén anticuados.
  \item Procesos aislados: Una característica importante del funcionamiento de libextractor es que las llamadas a los plugins externos usan ``\dfn{fork}''. Esto nos asegura que lo peor que puede ocurrir cuando intentamos extraer metadatos de un archivo corrupto o maligno es que el proceso del plugin muera y no nos devuelva metadatos. 
\end{itemize}

A pesar de que estas características son muy importantes, libextractor también tiene multiples inconvenientes:
\begin{itemize}
  \item Lentitud: A pesar de estar escrito en C, la carga de los plugins, la creación del fork y la copia del archivo a analizar puede ser lenta en comparación con el \dfn{spider} de Krptkn. Debido a esto, la velocidad de exploración de Krptkn se ve limitada. En la versión final de Krptkn, no se limita la velocidad de la spider pero cuando acaba la exploración hay que esperar hasta durante unos minutos para que todos los archivos descargados se puedan analizar.
  \item Paralelismo: Una de las principales ventajas de el uso de Erlang/Elixir y OTP es su capacidad para paralelizar el código de forma muy simple. El estar usando una librería nativa que hace uso de forks y lee librerías compartidas (.so, .a, .o) hace imposible aprovechar el paralelismo que se usa en el resto de módulos de Krptkn..
\end{itemize}

Estos problemas se podrían mitigar a la vez que mantenemos las ventajas haciendo uso de una librería de extracción de metadatos escrita en Elixir. Esto nos permitiría hacer uso de tantos procesos paralelos como fuera necesario, acelerando mucho la ejecución.

En las fases iniciales del proyecto se intentó crear un módulo para leer los metadatos de archivos PNG y se concluyó que aunque la creación del \dfn{parser} había sido bastante rápida (entre dos y tres horas), desarrollar los módulos necesarios para igualar a libextractor (pdf, word, mp3, ogg, avi, deb, etc.) iba a ser imposible sin un equipo o más tiempo.

En conclusión, lo más adecuado ahora mismo es usar libextractor y si fuera posible, ir creando parsers en Elixir para acelerar la fase de extracción. Ambos pueden ser usados a la vez gracias a la arquitectura de Krptkn por lo que el desarrollo de uno para archivos que sabemos que son muy comunes (pdf o jpg) podría acelerar mucho el sistema sin requerir demasiado tiempo.
